<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ Benchmark Test - Text-to-CAD</title>
    <link rel="stylesheet" href="/static/css/style.css?v=20250621">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
            overflow-y: auto;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }

        .controls {
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            margin: 20px;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .test-cases {
            display: flex;
            flex-direction: column;
            gap: 30px;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
            padding-bottom: 60px;
        }

        .test-case {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .test-case-header {
            margin-bottom: 20px;
            text-align: center;
        }

        .test-case-title {
            font-size: 1.5rem;
            color: #2d3748;
            margin-bottom: 8px;
        }

        .test-case-description {
            color: #4a5568;
            margin-bottom: 12px;
        }

        .test-case-prompt {
            background: #f7fafc;
            padding: 12px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            color: #2d3748;
            border-left: 4px solid #667eea;
        }

        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .viewport-container {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 16px;
            position: relative;
        }

        .viewport-header {
            text-align: center;
            margin-bottom: 12px;
            font-weight: 600;
            color: #2d3748;
        }

        .viewport-3d {
            width: 100%;
            height: 300px;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            background: #ffffff;
            border: 2px solid #e2e8f0;
        }

        /* OVERLAY VIEWPORT (IGUAL AO INDEX.HTML) */
        .viewport-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 8px;
        }

        .no-model-message {
            text-align: center;
            color: #666;
            font-size: 14px;
        }

        .status-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            z-index: 100;
        }

        .status-loading { background: #ffd700; color: #8b7000; }
        .status-success { background: #48bb78; color: white; }
        .status-error { background: #f56565; color: white; }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 25px;
            font-weight: 600;
            z-index: 1000;
        }

        .connected { background: #48bb78; color: white; }
        .disconnected { background: #f56565; color: white; }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <h1>üöÄ Benchmark Test - Text-to-CAD</h1>
        <p>Sistema de teste e compara√ß√£o autom√°tica entre LLM e Ground Truth</p>
    </div>

    <!-- Connection Status -->
    <div id="connection-status" class="connection-status disconnected">üîå Desconectado</div>

    <!-- Controls -->
    <div class="controls">
        <button id="run-all-tests" class="btn">ü§ñ Executar Testes LLM</button>
        <button id="clear-results" class="btn">üßπ Limpar Resultados</button>
        <button id="export-results" class="btn">üìä Exportar Resultados</button>
        <button id="debug-elements" class="btn" onclick="window.benchmarkManager.debugElements()">üîç Debug Elementos</button>
    </div>

    <!-- Test Cases Container -->
    <div id="test-cases" class="test-cases">
        <!-- Os casos de teste ser√£o carregados dinamicamente aqui -->
    </div>

    <!-- Scripts -->
    <script src="/static/js/three-setup.js"></script>
    <script src="/static/js/benchmark/case-loader.js"></script>
    <script src="/static/js/benchmark/websocket-client.js"></script>
    <script src="/static/js/benchmark/three-renderer.js"></script>
    <script>
        // Gerenciador principal do benchmark
        class BenchmarkManager {
            constructor() {
                this.testResults = new Map();
                this.currentTest = null;
                this.isRunning = false;
            }

            async init() {
                try {
                    console.log('üîÑ Carregando casos de teste...');
                    await window.benchmarkLoader.loadAllCases();
                    console.log('üì¶ Casos carregados:', window.benchmarkLoader.getAllCases().length);
                    
                    this.renderTestCases();
                    console.log('üé® Interface renderizada');
                    
                    await this.connectWebSocket();
                    console.log('üîå WebSocket conectado');
                    
                    this.setupEventListeners();
                    console.log('üéõÔ∏è Event listeners configurados');
                    
                    console.log('‚úÖ Benchmark Manager inicializado com sucesso');
                } catch (error) {
                    console.error('‚ùå Erro ao inicializar benchmark:', error);
                    alert(`Erro ao carregar benchmark: ${error.message}\nVerifique o console para mais detalhes.`);
                }
            }

            async connectWebSocket() {
                try {
                    await window.benchmarkWebSocket.connect({
                        onOpen: () => {
                            document.getElementById('connection-status').textContent = '‚úÖ Conectado';
                            document.getElementById('connection-status').className = 'connection-status connected';
                        },
                        onClose: () => {
                            document.getElementById('connection-status').textContent = 'üîå Desconectado';
                            document.getElementById('connection-status').className = 'connection-status disconnected';
                        },
                        onMessage: (data) => this.handleWebSocketMessage(data)
                    });
                } catch (error) {
                    console.error('‚ùå Erro ao conectar WebSocket:', error);
                }
            }

            renderTestCases() {
                const container = document.getElementById('test-cases');
                const cases = window.benchmarkLoader.getAllCases()
                    .sort((a, b) => {
                        // Ordenar por n√∫mero no ID (case-01, case-02, etc.)
                        const numA = parseInt(a.id.split('-')[1]);
                        const numB = parseInt(b.id.split('-')[1]);
                        return numA - numB;
                    });
                
                container.innerHTML = cases.map(testCase => `
                    <div class="test-case" data-case-id="${testCase.id}">
                        <div class="test-case-header">
                            <h3 class="test-case-title">${testCase.name}</h3>
                            <p class="test-case-description">${testCase.description}</p>
                            <div class="test-case-prompt">${testCase.prompt}</div>
                        </div>
                        
                        <div style="margin-bottom: 16px; text-align: center;">
                            <button class="btn" onclick="window.benchmarkManager.runSingleTest('${testCase.id}')" style="font-size: 14px; padding: 8px 16px; margin-right: 8px;">
                                ü§ñ Testar LLM
                            </button>
                            <button class="btn" onclick="window.benchmarkManager.reloadGroundTruth('${testCase.id}')" style="font-size: 14px; padding: 8px 16px; background: #28a745;">
                                üîÑ Recarregar GT
                            </button>
                        </div>
                        
                        <div class="comparison-container">
                            <div class="viewport-container">
                                <div class="viewport-header">ü§ñ Resultado do LLM</div>
                                <div class="viewport-3d" id="llm-viewport-${testCase.id}">
                                    <div class="viewport-overlay" id="llm-overlay-${testCase.id}">
                                        <div class="no-model-message">
                                            <p>ü§ñ Aguardando resultado do LLM...</p>
                                        </div>
                                    </div>
                                    <div class="status-indicator status-loading" id="llm-status-${testCase.id}">‚è≥ Aguardando</div>
                                </div>
                            </div>
                            
                            <div class="viewport-container">
                                <div class="viewport-header">‚öôÔ∏è Ground Truth</div>
                                <div class="viewport-3d" id="gt-viewport-${testCase.id}">
                                    <div class="viewport-overlay" id="gt-overlay-${testCase.id}">
                                        <div class="no-model-message">
                                            <p>‚öôÔ∏è Carregando Ground Truth...</p>
                                        </div>
                                    </div>
                                    <div class="status-indicator status-loading" id="gt-status-${testCase.id}">‚è≥ Aguardando</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('');

                // Inicializar viewports 3D ap√≥s um pequeno delay para garantir que o DOM foi atualizado
                setTimeout(() => {
                    cases.forEach(testCase => {
                        console.log(`üé® Inicializando viewports para ${testCase.id}`);
                        
                        // Verificar se os elementos existem
                        const llmViewport = document.getElementById(`llm-viewport-${testCase.id}`);
                        const gtViewport = document.getElementById(`gt-viewport-${testCase.id}`);
                        const llmStatus = document.getElementById(`llm-status-${testCase.id}`);
                        const gtStatus = document.getElementById(`gt-status-${testCase.id}`);
                        
                        console.log(`üîç Elementos encontrados para ${testCase.id}:`, {
                            llmViewport: !!llmViewport,
                            gtViewport: !!gtViewport, 
                            llmStatus: !!llmStatus,
                            gtStatus: !!gtStatus
                        });
                        
                        // DEBUG adicional - mostrar se os elementos de status est√£o realmente na DOM
                        if (!llmStatus) {
                            console.error(`‚ùå llm-status-${testCase.id} n√£o encontrado no DOM`);
                            console.log('DOM atual:', document.getElementById(`llm-viewport-${testCase.id}`)?.innerHTML);
                        }
                        if (!gtStatus) {
                            console.error(`‚ùå gt-status-${testCase.id} n√£o encontrado no DOM`);  
                            console.log('DOM atual:', document.getElementById(`gt-viewport-${testCase.id}`)?.innerHTML);
                        }
                        
                        if (llmViewport) {
                            try {
                                window.benchmarkRenderer.initViewport(`llm-viewport-${testCase.id}`, 'llm');
                            } catch (error) {
                                console.error(`‚ùå Erro ao inicializar LLM viewport para ${testCase.id}:`, error);
                            }
                        }
                        if (gtViewport) {
                            try {
                                window.benchmarkRenderer.initViewport(`gt-viewport-${testCase.id}`, 'gt');
                            } catch (error) {
                                console.error(`‚ùå Erro ao inicializar GT viewport para ${testCase.id}:`, error);
                            }
                        }
                    });
                    
                    // üéØ CARREGAR TODOS OS GROUND TRUTHS AP√ìS VIEWPORTS INICIALIZADOS
                    console.log('üéØ Carregando Ground Truths automaticamente...');
                    setTimeout(() => {
                        window.benchmarkManager.loadAllGroundTruths();
                    }, 200); // Aguardar mais um pouco para garantir que as cenas est√£o criadas
                    
                }, 100);
            }

            setupEventListeners() {
                document.getElementById('run-all-tests').addEventListener('click', () => this.runAllLLMTests());
                document.getElementById('clear-results').addEventListener('click', () => this.clearResults());
                document.getElementById('export-results').addEventListener('click', () => this.exportResults());
            }

            // üéØ Carregar todos os Ground Truths automaticamente
            async loadAllGroundTruths() {
                const cases = window.benchmarkLoader.getAllCases();
                
                console.log('üéØ Iniciando carregamento autom√°tico de Ground Truths...');
                
                // üöÄ ESTRAT√âGIA INTELIGENTE: Se API n√£o est√° respondendo, usar placeholders imediatamente
                const canUseAPI = window.benchmarkWebSocket.isConnected;
                console.log(`üîç API dispon√≠vel: ${canUseAPI}`);
                
                if (!canUseAPI) {
                    // Carregar todos os placeholders imediatamente
                    console.log('‚ö° Carregando placeholders diretamente (API indispon√≠vel)');
                    cases.forEach(testCase => {
                        this.loadGroundTruthPlaceholderDirect(testCase);
                    });
                } else {
                    // Tentar API com timeout curto
                    const groundTruthPromises = cases.map(testCase => 
                        this.executeGroundTruthAutomatic(testCase)
                    );
                    
                    try {
                        await Promise.all(groundTruthPromises);
                    } catch (error) {
                        console.error('‚ùå Erro ao carregar Ground Truths automaticamente:', error);
                    }
                }
                
                console.log('‚úÖ Todos os Ground Truths carregados automaticamente!');
            }
            
            // Carregar placeholder diretamente (sem API)
            loadGroundTruthPlaceholderDirect(testCase) {
                const statusEl = document.getElementById(`gt-status-${testCase.id}`);
                const viewportId = `gt-viewport-${testCase.id}`;
                
                if (!statusEl) {
                    console.error(`‚ùå Elemento gt-status-${testCase.id} n√£o encontrado`);
                    return;
                }
                
                console.log(`‚ö° Carregando modelo direto: ${testCase.name}`);
                
                statusEl.textContent = '‚úÖ Carregado';
                statusEl.className = 'status-indicator status-success';
                
                // üéØ Carregar modelo espec√≠fico para este caso de teste
                window.benchmarkRenderer.loadGroundTruthModel(viewportId, testCase.id);
                
                console.log(`‚úÖ Ground Truth carregado: ${testCase.name}`);
            }

            // Execu√ß√£o autom√°tica do Ground Truth (sem aguardar clique)
            async executeGroundTruthAutomatic(testCase) {
                const statusEl = document.getElementById(`gt-status-${testCase.id}`);
                if (!statusEl) {
                    console.error(`‚ùå Elemento gt-status-${testCase.id} n√£o encontrado para carregamento autom√°tico`);
                    return;
                }
                
                console.log(`üéØ Executando Ground Truth Code: ${testCase.name}`);
                statusEl.textContent = '‚è≥ Executando...';
                statusEl.className = 'status-indicator status-loading';
                
                try {
                    // üöÄ EXECUTAR GROUND TRUTH CODE REAL VIA API
                    const response = await fetch('/api/execute_groundtruth', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            case_id: testCase.id,
                            ground_truth_code: testCase.groundTruthCode
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Erro HTTP ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    if (result.success && result.mesh_data) {
                        console.log(`‚úÖ Ground Truth executado com sucesso: ${testCase.name}`);
                        
                        // Renderizar mesh real no viewport
                        const viewportId = `gt-viewport-${testCase.id}`;
                        await window.benchmarkRenderer.renderRealMesh(viewportId, result.mesh_data, testCase);
                        
                        statusEl.textContent = '‚úÖ Executado';
                        statusEl.className = 'status-indicator status-success';
                    } else {
                        throw new Error(result.error || 'Erro desconhecido');
                    }
                    
                } catch (error) {
                    console.error(`‚ùå Erro ao carregar Ground Truth automaticamente ${testCase.name}:`, error);
                    statusEl.textContent = '‚ùå Erro';
                    statusEl.className = 'status-indicator status-error';
                    window.benchmarkRenderer.loadPlaceholderModel(`gt-viewport-${testCase.id}`, 'error');
                }
            }
            
            // Gerar modelo Ground Truth via API
            async generateGroundTruthModel(testCase) {
                const statusEl = document.getElementById(`gt-status-${testCase.id}`);
                const viewportId = `gt-viewport-${testCase.id}`;
                
                // üöÄ OTIMIZA√á√ÉO: Primeiro tentar placeholder diretamente se API n√£o est√° configurada
                if (!window.benchmarkWebSocket.isConnected) {
                    console.log(`‚ö° WebSocket n√£o conectado para ${testCase.name}, usando placeholder diretamente`);
                    this.loadGroundTruthPlaceholder(testCase, statusEl, viewportId);
                    return;
                }
                
                try {
                    // Tentar executar via WebSocket (mesma API do sistema principal)
                    statusEl.textContent = 'üîÑ Executando...';
                    statusEl.className = 'status-indicator status-loading';
                    
                    const success = await this.executeGroundTruthViaAPI(testCase);
                    
                    if (success) {
                        statusEl.textContent = '‚úÖ Carregado';
                        statusEl.className = 'status-indicator status-success';
                        console.log(`‚úÖ Ground Truth carregado via API: ${testCase.name}`);
                    } else {
                        throw new Error('Falha na execu√ß√£o via API');
                    }
                    
                } catch (error) {
                    console.log(`‚ö†Ô∏è API falhou para ${testCase.name}, usando placeholder`);
                    this.loadGroundTruthPlaceholder(testCase, statusEl, viewportId);
                }
            }
            
            // Carregar placeholder para Ground Truth
            loadGroundTruthPlaceholder(testCase, statusEl, viewportId) {
                statusEl.textContent = '‚úÖ Simulado';
                statusEl.className = 'status-indicator status-success';
                
                // üéØ Carregar modelo espec√≠fico para este caso de teste
                window.benchmarkRenderer.loadGroundTruthModel(viewportId, testCase.id);
                
                console.log(`‚úÖ Ground Truth simulado: ${testCase.name}`);
            }
            
            // Executar Ground Truth via WebSocket API
            async executeGroundTruthViaAPI(testCase) {
                return new Promise((resolve) => {
                    // ‚ùå DESABILITADO: N√ÉO enviar ground truth para LLM!
                    // Isso vazaria as respostas corretas para o modelo
                    console.log(`üö´ Ground Truth API desabilitado para ${testCase.name} (evitar vazamento)`);
                    
                    // Sempre falhar para for√ßar uso de placeholder
                    setTimeout(() => {
                        resolve(false);
                    }, 100);
                });
            }

            async runAllLLMTests() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                const button = document.getElementById('run-all-tests');
                button.textContent = '‚è≥ Executando LLM...';
                button.disabled = true;
                
                const cases = window.benchmarkLoader.getAllCases();
                
                for (const testCase of cases) {
                    console.log(`ü§ñ Executando teste LLM: ${testCase.name}`);
                    await this.executeLLMTest(testCase);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                this.isRunning = false;
                button.textContent = 'ü§ñ Executar Testes LLM';
                button.disabled = false;
                console.log('‚úÖ Todos os testes LLM conclu√≠dos');
            }

            async runSingleTest(caseId) {
                if (this.isRunning) return;
                
                const testCase = window.benchmarkLoader.getCaseById(caseId);
                if (!testCase) {
                    console.error(`‚ùå Caso ${caseId} n√£o encontrado`);
                    return;
                }
                
                console.log(`ü§ñ Executando teste LLM individual: ${testCase.name}`);
                await this.executeLLMTest(testCase);
                console.log(`‚úÖ Teste LLM ${testCase.name} conclu√≠do`);
            }
            
            // Recarregar Ground Truth individual (se necess√°rio)
            async reloadGroundTruth(caseId) {
                const testCase = window.benchmarkLoader.getCaseById(caseId);
                if (!testCase) {
                    console.error(`‚ùå Caso ${caseId} n√£o encontrado`);
                    return;
                }
                
                console.log(`üîÑ Recarregando Ground Truth: ${testCase.name}`);
                await this.executeGroundTruthAutomatic(testCase);
            }

            async executeGroundTruth(testCase) {
                const statusEl = document.getElementById(`gt-status-${testCase.id}`);
                if (!statusEl) {
                    console.error(`‚ùå Elemento gt-status-${testCase.id} n√£o encontrado`);
                    return;
                }
                
                console.log(`üöÄ Executando Ground Truth: ${testCase.name}`);
                statusEl.textContent = '‚è≥ Executando...';
                statusEl.className = 'status-indicator status-loading';
                
                try {
                    // Mostrar placeholder de loading imediatamente
                    window.benchmarkRenderer.loadPlaceholderModel(`gt-viewport-${testCase.id}`, 'loading');
                    
                    // Definir teste atual
                    this.currentTest = { testCase, type: 'ground-truth' };
                    
                    // Enviar c√≥digo para execu√ß√£o
                    const message = `Execute este c√≥digo CadQuery e retorne o modelo 3D como STL:\n\n${testCase.groundTruthCode}`;
                    window.benchmarkWebSocket.sendUserMessage(message);
                    
                    // Aguardar resposta com timeout
                    return new Promise((resolve) => {
                        const timeout = setTimeout(() => {
                            if (this.currentTest && this.currentTest.testCase.id === testCase.id) {
                                statusEl.textContent = '‚è∞ Timeout';
                                statusEl.className = 'status-indicator status-error';
                                this.currentTest = null;
                            }
                            resolve();
                        }, testCase.timeout);
                        
                        // Salvar o timeout para poder cancelar
                        this.currentTest.timeout = timeout;
                    });
                    
                } catch (error) {
                    console.error('‚ùå Erro ao executar Ground Truth:', error);
                    statusEl.textContent = '‚ùå Erro';
                    statusEl.className = 'status-indicator status-error';
                    window.benchmarkRenderer.loadPlaceholderModel(`gt-viewport-${testCase.id}`, 'error');
                }
            }

            async executeLLMTest(testCase) {
                const statusEl = document.getElementById(`llm-status-${testCase.id}`);
                if (!statusEl) {
                    console.error(`‚ùå Elemento llm-status-${testCase.id} n√£o encontrado`);
                    return;
                }
                
                console.log(`ü§ñ Executando LLM: ${testCase.name}`);
                statusEl.textContent = '‚è≥ Executando...';
                statusEl.className = 'status-indicator status-loading';
                
                try {
                    // Mostrar placeholder de loading imediatamente
                    window.benchmarkRenderer.loadPlaceholderModel(`llm-viewport-${testCase.id}`, 'loading');
                    
                    // Definir teste atual
                    this.currentTest = { testCase, type: 'llm' };
                    
                    // Enviar prompt para LLM
                    window.benchmarkWebSocket.sendUserMessage(testCase.prompt);
                    
                    // Aguardar resposta com timeout
                    return new Promise((resolve) => {
                        const timeout = setTimeout(() => {
                            if (this.currentTest && this.currentTest.testCase.id === testCase.id) {
                                statusEl.textContent = '‚è∞ Timeout';
                                statusEl.className = 'status-indicator status-error';
                                this.currentTest = null;
                            }
                            resolve();
                        }, testCase.timeout);
                        
                        // Salvar o timeout para poder cancelar
                        this.currentTest.timeout = timeout;
                    });
                    
                } catch (error) {
                    console.error('‚ùå Erro ao executar teste LLM:', error);
                    statusEl.textContent = '‚ùå Erro';
                    statusEl.className = 'status-indicator status-error';
                    window.benchmarkRenderer.loadPlaceholderModel(`llm-viewport-${testCase.id}`, 'error');
                }
            }

            handleWebSocketMessage(data) {
                if (!this.currentTest) return;
                
                console.log('üì® Mensagem WebSocket recebida:', data);
                
                const { testCase, type, timeout, resolve } = this.currentTest;
                
                if (data.type === 'system_response' && data.data) {
                    const response = data.data;
                    
                    // Cancelar timeout
                    if (timeout) {
                        clearTimeout(timeout);
                    }
                    
                    // Determinar viewport baseado no tipo
                    let viewportId, statusId;
                    if (type === 'llm') {
                        viewportId = `llm-viewport-${testCase.id}`;
                        statusId = `llm-status-${testCase.id}`;
                    } else if (type === 'ground-truth' || type === 'ground-truth-auto') {
                        viewportId = `gt-viewport-${testCase.id}`;
                        statusId = `gt-status-${testCase.id}`;
                    }
                    
                    const statusEl = document.getElementById(statusId);
                    
                    if (!statusEl) {
                        console.error(`‚ùå Elemento ${statusId} n√£o encontrado`);
                        if (resolve) resolve(false);
                        return;
                    }
                    
                    if (response.stl_data) {
                        // Carregar modelo 3D
                        window.benchmarkRenderer.loadSTLModel(viewportId, response.stl_data)
                            .then(() => {
                                statusEl.textContent = '‚úÖ Sucesso';
                                statusEl.className = 'status-indicator status-success';
                                console.log(`‚úÖ ${type} ${testCase.name} - Modelo 3D carregado`);
                                if (resolve) resolve(true);
                            })
                            .catch((error) => {
                                console.error('‚ùå Erro ao carregar 3D:', error);
                                statusEl.textContent = '‚ùå Erro 3D';
                                statusEl.className = 'status-indicator status-error';
                                window.benchmarkRenderer.loadPlaceholderModel(viewportId, 'error');
                                if (resolve) resolve(false);
                            });
                    } else {
                        // Sem modelo 3D
                        statusEl.textContent = '‚ö†Ô∏è Sem 3D';
                        statusEl.className = 'status-indicator status-error';
                        window.benchmarkRenderer.loadPlaceholderModel(viewportId, 'error');
                        console.log(`‚ö†Ô∏è ${type} ${testCase.name} - Sem dados 3D`);
                        if (resolve) resolve(false);
                    }
                    
                    // Limpar teste atual se n√£o tem resolve (modo normal)
                    if (!resolve) {
                        this.currentTest = null;
                    }
                }
            }

            clearResults() {
                const cases = window.benchmarkLoader.getAllCases();
                cases.forEach(testCase => {
                    // Limpar status LLM
                    const llmStatus = document.getElementById(`llm-status-${testCase.id}`);
                    if (llmStatus) {
                        llmStatus.textContent = '‚è≥ Aguardando';
                        llmStatus.className = 'status-indicator status-loading';
                    }
                    
                    // Limpar status Ground Truth
                    const gtStatus = document.getElementById(`gt-status-${testCase.id}`);
                    if (gtStatus) {
                        gtStatus.textContent = '‚è≥ Aguardando';
                        gtStatus.className = 'status-indicator status-loading';
                    }
                    
                    window.benchmarkRenderer.clearModels(`llm-viewport-${testCase.id}`);
                    window.benchmarkRenderer.clearModels(`gt-viewport-${testCase.id}`);
                    window.benchmarkRenderer.showMessage(`llm-viewport-${testCase.id}`, 'ü§ñ Aguardando resultado do LLM...');
                    window.benchmarkRenderer.showMessage(`gt-viewport-${testCase.id}`, '‚öôÔ∏è Aguardando Ground Truth...');
                });
                
                this.testResults.clear();
                console.log('üßπ Resultados limpos');
            }

            exportResults() {
                const results = Array.from(this.testResults.entries());
                const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `benchmark-results-${new Date().toISOString().slice(0, 19)}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            // M√©todo de debug para testar elementos
            debugElements() {
                console.log('üîç Debug dos elementos DOM:');
                const cases = window.benchmarkLoader.getAllCases();
                cases.forEach(testCase => {
                    console.log(`üìã Caso: ${testCase.id}`);
                    console.log(`  LLM Viewport: ${!!document.getElementById(`llm-viewport-${testCase.id}`)}`);
                    console.log(`  LLM Status: ${!!document.getElementById(`llm-status-${testCase.id}`)}`);
                    console.log(`  GT Viewport: ${!!document.getElementById(`gt-viewport-${testCase.id}`)}`);
                    console.log(`  GT Status: ${!!document.getElementById(`gt-status-${testCase.id}`)}`);
                });
            }
        }

        // Inicializar quando p√°gina carregar
        document.addEventListener('DOMContentLoaded', async () => {
            const manager = new BenchmarkManager();
            await manager.init();
            window.benchmarkManager = manager;
        });
    </script>
</body>
</html> 